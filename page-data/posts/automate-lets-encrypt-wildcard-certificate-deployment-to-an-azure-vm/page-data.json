{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/automate-lets-encrypt-wildcard-certificate-deployment-to-an-azure-vm","result":{"data":{"markdownRemark":{"id":"76c5eaac-051a-5af2-8d36-955e11a0b295","html":"<p>Automating TLS certificate issuing via <code class=\"language-text\">Let&#39;s Encrypt</code> is very straight-forward in new emerging orchestrators like Kubernetes. Achieving the same on a virtual machine running IIS is still very much in demand, but the process is not well documented and a little bit more difficult to get right.</p>\n<ul>\n<li><a href=\"#the-agument-for-automating-certificate-issuing-process\">The agument for automating certificate issuing process</a></li>\n<li><a href=\"#lets-encrypt-in-kubernetes-vs-windows-iis\">Let’s Encrypt in Kubernetes vs Windows IIS</a></li>\n<li><a href=\"#the-difference-between-wildcard-and-regular-tls-certificates\">The difference between wildcard and regular TLS certificates</a></li>\n<li><a href=\"#step-1-automate-wildcard-certificate-issuing-using-azure-functions-and-key-vault\">Step 1 Automate wildcard certificate issuing using Azure functions and key vault</a></li>\n<li><a href=\"#step-2-link-a-vm-with-azure-keyvault\">Step 2 Link a VM with Azure KeyVault</a></li>\n<li><a href=\"#step-3-testing-things-out\">Step 3 Testing things out</a></li>\n<li><a href=\"#step-4-keeping-bindings-up-to-date-with-new-certificates\">Step 4 Keeping bindings up to date with new certificates</a></li>\n<li><a href=\"#summary\">Summary</a></li>\n</ul>\n<h2 id=\"the-agument-for-automating-certificate-issuing-process\" style=\"position:relative;\"><a href=\"#the-agument-for-automating-certificate-issuing-process\" aria-label=\"the agument for automating certificate issuing process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The agument for automating certificate issuing process</h2>\n<p>Encrypting all traffic that travels over public internet in this day and age is a no-brainer. The introduction of nonprofit Certificate Authority (CA) like Let’s Encrypt significantly streamlines the whole process. There are those who say trusting a nonprofit organisation with TLS encryption is a mistake, because there’s less skin in the game on the CA behalf if they get hacked. I can see the argument from both angles, but strongly believe the old/manual way of issuing and installing certificates (having gone through the process myself very recently) is simply not fit for purpose in modern age.</p>\n<h2 id=\"lets-encrypt-in-kubernetes-vs-windows-iis\" style=\"position:relative;\"><a href=\"#lets-encrypt-in-kubernetes-vs-windows-iis\" aria-label=\"lets encrypt in kubernetes vs windows iis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Let’s Encrypt in Kubernetes vs Windows IIS</h2>\n<p>In Kubernetes world, automating certificate issuing is almost stupid-easy: Install cert-manager (via helm), deploy a cluster-issuer and add annotation to ingress (cert-manager.io/issuer: “letsencrypt”). Job done, you never have to worry about renewing a certificate again.</p>\n<p>With virtual machines and IIS, the process is more involved. Especially if you plan to use wildcard certificates, but once you set it up correctly, you can reap the same benefits of not having to worry about regular certificate renewal.</p>\n<h2 id=\"the-difference-between-wildcard-and-regular-tls-certificates\" style=\"position:relative;\"><a href=\"#the-difference-between-wildcard-and-regular-tls-certificates\" aria-label=\"the difference between wildcard and regular tls certificates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The difference between wildcard and regular TLS certificates</h2>\n<p>A regular certificate is only valid for a specific sub-domain it was issued for. For instance, <code class=\"language-text\">myblog.myworld.com</code>. Let’s Encrypt needs to complete <code class=\"language-text\">HTTP-01 challenge</code> in order to issue such a certificate. Put simply, the CA (Let’s Encrypt) generates a token and then tries to access <code class=\"language-text\">http://&lt;YOUR_DOMAIN&gt;/.well-known/acme-challenge/&lt;TOKEN&gt;</code>. If it gets a 200OK response, it is a proof that you own this domain, because you were able to set up a service that responds to their requests at the URL they specified.</p>\n<p>A wildcard certificate is able to encrypt/decrypt traffic for a specific domain, but also any sub-domain (<code class=\"language-text\">*.myworld.com</code>). As such, the HTTP-01 challenge is no longer sufficient, because it is impossible to generate and verify a token for every possible subdomain that can exist. Therefore, a <code class=\"language-text\">DNS-01</code> challenge has to performed. It involves creating a specific DNS record for your domain (again, Let’s Encrypt will decide what that record should look like). If you’re able to create this record, and Let’s Encrypt is able to access it, then again this will serve as proof that you are the owner this domain and a wildcard certificate can be issued.</p>\n<p>You can read more about Let’s Encrypt challenge types <a href=\"https://letsencrypt.org/docs/challenge-types/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.</p>\n<h2 id=\"step-1-automate-wildcard-certificate-issuing-using-azure-functions-and-key-vault\" style=\"position:relative;\"><a href=\"#step-1-automate-wildcard-certificate-issuing-using-azure-functions-and-key-vault\" aria-label=\"step 1 automate wildcard certificate issuing using azure functions and key vault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 1 Automate wildcard certificate issuing using Azure functions and key vault</h2>\n<p>The first objective is to automate wildcard certificate issuing and place the certificate in a key vault. A virtual machine can then link up with the key vault securely using a VM extension and download a new certificate when it becomes available.</p>\n<p>Fortunately, clever people already did most of the leg-work for us and there is no point in trying to re-invent the wheel. Have a look at <a href=\"https://github.com/shibayan/keyvault-acmebot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Key Vault Acmebot</a>. The process is well documented. If you manage your DNS and Key Vault in Azure, it will take care of automatically creating the correct DNS record every 60 days and placing a new wildcard certificate in a key vault.</p>\n<h2 id=\"step-2-link-a-vm-with-azure-keyvault\" style=\"position:relative;\"><a href=\"#step-2-link-a-vm-with-azure-keyvault\" aria-label=\"step 2 link a vm with azure keyvault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 2 Link a VM with Azure KeyVault</h2>\n<p>To link up a VM with an Azure Key Vault, you can use an Azure VM extension. I’m a proponent of terraform, but you can equally just create the extension manually or using Azure deployment templates:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">resource \"azurerm_virtual_machine_scale_set_extension\" \"keyvault_extension\" <span class=\"token punctuation\">{</span>\n  provider                     = azurerm.provideralias\n  name                         = var.keyvault_extension_profile.name\n  virtual_machine_scale_set_id = var.virtual_machine_scale_set_id\n  publisher                    = var.keyvault_extension_profile.publisher\n  type                         = var.keyvault_extension_profile.type\n  type_handler_version         = var.keyvault_extension_profile.type_handler_version\n  auto_upgrade_minor_version   = var.keyvault_extension_profile.auto_upgrade_minor_version\n  settings = &lt;&lt;EOF\n      <span class=\"token punctuation\">{</span>\n        <span class=\"token key atrule\">\"secretsManagementSettings\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token key atrule\">\"pollingIntervalInS\"</span><span class=\"token punctuation\">:</span>       <span class=\"token string\">\"${var.keyvault_extension_profile.polling_interval_in_s}\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token key atrule\">\"certificateStoreName\"</span><span class=\"token punctuation\">:</span>     <span class=\"token string\">\"${var.keyvault_extension_profile.certificate_store_name}\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token key atrule\">\"certificateStoreLocation\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"${var.keyvault_extension_profile.certificate_store_location}\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token key atrule\">\"observedCertificates\"</span><span class=\"token punctuation\">:</span>     $<span class=\"token punctuation\">{</span>var.keyvault_extension_profile.observed_certificates<span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> \n      <span class=\"token punctuation\">}</span>\n    EOF\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You will need to provide a series of settings, so that the extension knows where to retrieve certificate from, how often and where to store it on the local machine. Here’s an example of these settings:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">vmss_keyvault_extension_profile = <span class=\"token punctuation\">{</span>\n  name                       = \"KVVMExtensionForWindows\"\n  publisher                  = \"Microsoft.Azure.KeyVault\"\n  type                       = \"KeyVaultForWindows\"\n  type_handler_version       = \"1.0\" \n  auto_upgrade_minor_version = true\n  polling_interval_in_s      = \"3600\"\n  certificate_store_name     = \"MY\"\n  link_on_renewal            = false\n  certificate_store_location = \"LocalMachine\"\n  require_initial_sync       = true\n  observed_certificates  = \"<span class=\"token punctuation\">[</span>\\\"https<span class=\"token punctuation\">:</span>//kv<span class=\"token punctuation\">-</span>acmebot<span class=\"token punctuation\">-</span>xyzv.vault.azure.net/secrets/wildcard<span class=\"token punctuation\">-</span>certificate<span class=\"token punctuation\">-</span>name\\\"<span class=\"token punctuation\">]</span>\"  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The key setting to pay attention to is <code class=\"language-text\">observed_certificates</code>:</p>\n<ul>\n<li><code class=\"language-text\">kv-acmebot-xyzv</code> is the name of your key vault. Has to be globally unique.</li>\n<li><code class=\"language-text\">wildcard-certificate-name</code> is the name of the certificate in your key vault.</li>\n</ul>\n<p>At this point you should be asking: How can the VM access the key vault? Does it not require an access policy? The answer is: Yes, it does. The easiest way to do this is to enable <code class=\"language-text\">Managed Identity</code> for the Virtual Machine or Virtual Machine Scaleset. In terraform this can be achieved by specifying:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">  identity <span class=\"token punctuation\">{</span>\n    type = \"SystemAssigned\"\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once your VM or scale set has a system-assigned identity, you can go ahead and create the key vault policy. In terraform:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">resource \"azurerm_key_vault_access_policy\" \"kv_access_policy\" <span class=\"token punctuation\">{</span>\n  provider                = azurerm.mysubscription\n  key_vault_id            = data.azurerm_key_vault.kv_acmebot.id\n  tenant_id               = data.azurerm_key_vault.kv_acmebot.tenant_id\n  object_id               = var.vm_identity_principal_id\n  certificate_permissions = <span class=\"token punctuation\">[</span><span class=\"token string\">\"Get\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"List\"</span><span class=\"token punctuation\">]</span>\n  key_permissions         = <span class=\"token punctuation\">[</span><span class=\"token string\">\"Get\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"List\"</span><span class=\"token punctuation\">]</span>\n  secret_permissions      = <span class=\"token punctuation\">[</span><span class=\"token string\">\"Get\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"List\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">object_id</code> here reffers to the system-assigned identity id of your VM or scale set. The super-important thing to remeber here, is that just creating an access policy with “Get” and “List” <code class=\"language-text\">certificate_permissions</code> will not be sufficient, The policy also requires “Get” and “List” <code class=\"language-text\">secret_permissions</code>. This is not untuitive. One would expect that storing and retrieving a TLS certificate from a key vault, the policy only requires <code class=\"language-text\">certificate_permissions</code>. However, HTTPS TLS certificate at the receiving end requires a private key to decrypt the traffic. The certificate is usually stored in PFX format and private key portion of it is stored separately as a <code class=\"language-text\">secret</code> (not a <code class=\"language-text\">certificate</code>) in a key vault. This fact is not obvious at all when interacting with the Key Vault using UI interface and will only become apparent after extensive trial/error/debugging.</p>\n<h2 id=\"step-3-testing-things-out\" style=\"position:relative;\"><a href=\"#step-3-testing-things-out\" aria-label=\"step 3 testing things out permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 3 Testing things out</h2>\n<p>The key milestones to check for during the set up process are:</p>\n<ul>\n<li>Is the Azure function able to create DNS records and place certificates in a key vault?</li>\n<li>Is the VM or scale set key vault extension throwing any errors? (check logs on C drive)</li>\n<li>Does the certificate appear in the certificate store on the virtual machine and does it contain a private key?</li>\n<li>Is all of this still working if you tear down and spin up a new VM/scale set? (remember, managed identity will change, new key vault access policy required)</li>\n<li>Is all of this still working after 60 days when the current certificate expires and renewal is required?</li>\n</ul>\n<h2 id=\"step-4-keeping-bindings-up-to-date-with-new-certificates\" style=\"position:relative;\"><a href=\"#step-4-keeping-bindings-up-to-date-with-new-certificates\" aria-label=\"step 4 keeping bindings up to date with new certificates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 4 Keeping bindings up to date with new certificates</h2>\n<p>Any HTTPS bindings created in IIS need to be associated with a specific PFX certificate from the certificate store. All Let’s Encrypt certificates are only valid for 90 days in total and renewal process should kick in after 60 days. The VM extension is polling the key vault in regular intervals, so when a new certificate is issued and placed in a key vault, the extension will automatically pick it up and place it in a certificate store on the VM. It will not replace the existing certificate, however. Both certificates will co-exist in the cert store. They will have identical names and subjects, but different expiry dates. So, the final step to full automation is to update any IIS bindings from pointing at the old certificate to point at the new certificate. I’ve written a PowerShell script to do this and set it to run as a scheduled task on the VM:</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\"><span class=\"token variable\">$certSubject</span> = <span class=\"token string\">\"CN=*.yourdomain.com\"</span>\n\n<span class=\"token variable\">$certificate</span> = <span class=\"token function\">Get-ChildItem</span> Cert:\\LocalMachine\\My <span class=\"token punctuation\">|</span> <span class=\"token function\">Where-Object</span> <span class=\"token punctuation\">{</span> <span class=\"token variable\">$_</span><span class=\"token punctuation\">.</span>Subject <span class=\"token operator\">-eq</span> <span class=\"token variable\">$certSubject</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">|</span> <span class=\"token function\">Sort-Object</span> <span class=\"token operator\">-</span>Property NotAfter <span class=\"token operator\">-</span>Descending <span class=\"token punctuation\">|</span> <span class=\"token function\">Select-Object</span> <span class=\"token operator\">-</span>First 1\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-Not</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">$certificate</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Write-Host</span> <span class=\"token string\">\"Unable to find certificate with subject <span class=\"token variable\">$certSubject</span>\"</span>\n    <span class=\"token keyword\">exit</span> 1\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Write-Host</span> <span class=\"token punctuation\">(</span><span class=\"token namespace\">[string]</span>::Format<span class=\"token punctuation\">(</span><span class=\"token string\">\"Found certificate in cert store with subject {0}, thumbprint {1}, expiring on {2}\"</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$certificate</span><span class=\"token punctuation\">.</span>Subject<span class=\"token punctuation\">,</span> <span class=\"token variable\">$certificate</span><span class=\"token punctuation\">.</span>Thumbprint<span class=\"token punctuation\">,</span> <span class=\"token variable\">$certificate</span><span class=\"token punctuation\">.</span>NotAfter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token variable\">$bindings</span> = <span class=\"token function\">Get-WebBinding</span> <span class=\"token punctuation\">|</span> <span class=\"token function\">Where-Object</span> <span class=\"token punctuation\">{</span> <span class=\"token variable\">$_</span><span class=\"token punctuation\">.</span>protocol <span class=\"token operator\">-eq</span> <span class=\"token string\">\"https\"</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token variable\">$bindings</span> <span class=\"token punctuation\">|</span> <span class=\"token function\">ForEach-Object</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token variable\">$bindingInfo</span> = <span class=\"token variable\">$_</span><span class=\"token punctuation\">.</span>bindingInformation<span class=\"token punctuation\">.</span>Split<span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token variable\">$hostHeader</span> = <span class=\"token variable\">$bindingInfo</span><span class=\"token punctuation\">[</span>2<span class=\"token punctuation\">]</span>\n\n    <span class=\"token variable\">$httpsBindingCert</span> = <span class=\"token function\">Get-Item</span> <span class=\"token operator\">-</span>Path <span class=\"token string\">\"IIS:\\SslBindings\\!443!<span class=\"token variable\">$hostHeader</span>\"</span> <span class=\"token operator\">-</span>ErrorAction SilentlyContinue\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">$httpsBindingCert</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Write-Host</span> <span class=\"token punctuation\">(</span><span class=\"token namespace\">[string]</span>::Format<span class=\"token punctuation\">(</span><span class=\"token string\">\"Existing binding uses certificate with thumbprint {0}\"</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$httpsBindingCert</span><span class=\"token punctuation\">.</span>Thumbprint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">$httpsBindingCert</span><span class=\"token punctuation\">.</span>Thumbprint <span class=\"token operator\">-eq</span> <span class=\"token variable\">$certificate</span><span class=\"token punctuation\">.</span>Thumbprint<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">Write-Host</span> <span class=\"token string\">\"Identical certificates, taking no action.\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">Write-Host</span> <span class=\"token string\">\"Updating certificate...\"</span>\n            <span class=\"token function\">Remove-Item</span> <span class=\"token operator\">-</span>Path <span class=\"token string\">\"IIS:\\SslBindings\\!443!<span class=\"token variable\">$hostHeader</span>\"</span>\n            <span class=\"token function\">New-Item</span> <span class=\"token operator\">-</span>Path <span class=\"token string\">\"IIS:\\SslBindings\\!443!<span class=\"token variable\">$hostHeader</span>\"</span> <span class=\"token operator\">-</span>Value <span class=\"token variable\">$certificate</span> <span class=\"token operator\">-</span>SSLFlags 1\n            <span class=\"token function\">Write-Host</span> <span class=\"token string\">\"Certificate updated.\"</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The powershell script will look for certificates with the specified subject, order them by expiry date and pick the latest one. It will then iterate through all HTTPS bindings in IIS and check if the thumbprint matches the latest certificate. If it does, no action is needed. If it doesn’t, the HTTPS binding is updated to point at the new certificate.</p>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>It is obvious that setting up a fully automated wildcard certificate issuing via Let’s Encrypt in a Windows virtual machine world is riddled with pitfalls and it takes a while to fine-tune the whole process, so that it executes reliably every 60 days without needing any manual intervention. Having these mundane tasks fully automated is oddly satisfying though. Just don’t automate yourself out of a job.</p>","fields":{"slug":"/posts/automate-lets-encrypt-wildcard-certificate-deployment-to-an-azure-vm","tagSlugs":["/tag/azure/","/tag/virtual-machines/","/tag/lets-encrypt/","/tag/wildcard-certificate/"]},"frontmatter":{"date":"2021-02-21T14:48:32.169Z","description":"Automating TLS certificate issuing via Let's Encrypt is very straight-forward in new emerging orchestrators like Kubernetes. Achieving the same on a virtual machine running IIS is still very much in demand, but the process is not well documented and a little bit more difficult to get right.","tags":["Azure","Virtual Machines","LetsEncrypt","Wildcard certificate"],"title":"Automate Let's Encrypt wildcard certificate deployment to an Azure VM","socialImage":"../../media/letsencrypt-wildcard-automation.jpg"}}},"pageContext":{"slug":"/posts/automate-lets-encrypt-wildcard-certificate-deployment-to-an-azure-vm"}},"staticQueryHashes":["251939775","3942705351","401334301"]}